= ArchDuke - Developer Guide
:toc:
:toc-title: Table of Contents
:toc-placement: preamble
:repoURL: https://github.com/AY1920S1-CS2113-T13-1/main

By: `CS2113-T13-1`      Since: `Aug 2019`      Licence: `MIT`

== Preface
=== About ArchDuke
Team leaders often face problems managing multiple projects, especially software development projects where the usage of a Kanban board is common.

Having to manage multiple Kanban boards for each individual project is a huge hassle for team leaders.
As such, ArchDuke solves this issue by allowing team leaders to manage

. Team members

* ArchDuke allows users to assign tasks to team members, and track their workload, progress on tasks, and contributions.

. Tasks in a group project

* ArchDuke allows users to track multiple tasks within a project. Tasks can be created and assigned to members.
* ArchDuke tracks the deadlines and priority levels of tasks, to help the user organise which tasks should be assigned
and completed.

. Multiple group projects

* ArchDuke allows users to track multiple group projects. New group projects can be created and a default Kanban board will be created for users to start adding tasks.

=== Document Change History
[width="100%",cols="25%, <75%", options="header"]
|=======================================================================
| Revision Date | Summary of Changes
| 23 October 2019   | Version 1.0: Added implementation design for Assignment Controller and Project functions
| 22 October 2019   | Version 0.9: Updated Architecture Design
| 15 October 2019   | Version 0.8: Updated the name of project from Duke to ArchDuke
| 2 October 2019    | Version 0.7: Updated Prerequisites and removed unwanted lines
| 30 September 2019 | Version 0.6: Added table of contents, preface and document history
| 26 September 2019 | Version 0.5: Updated use cases for a cleaner look
| 24 September 2019 | Version 0.4: Added Non-functional Requirements to DeveloperGuide
| 23 September 2019 | Version 0.3: Added user stories to DeveloperGuide
| 22 September 2019 | Version 0.2: Added use cases to DeveloperGuide
| 18 September 2019 | Version 0.1: Creation of DeveloperGuide based on template
|=======================================================================

== 1. Setting up

=== 1.1. Prerequisites

. *JDK `11`* or above is required
. *IntelliJ* IDE is recommended
+
// [NOTE]
// IntelliJ by default has Gradle and JavaFx plugins installed. +
// Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== 1.2. Setting up the project environment on your local machine.

. Fork and clone the forked remote on your local machine.
. Launch IntelliJ (If you’re not on the IntelliJ Welcome screen please close your  existing project by going to `File` > `Close Project`.)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Structure for New Projects`
.. Under `Project Settings` Click on `Project`
.. Under `Project SDK` Click `New…` and point it to JDK 11 path.
.. Click `OK` to save the configuration
. Click `Import Project`
.  Locate the `build.gradle` file and select it. Click `Open`.
. Open the IntelliJ console/terminal and run the gradle command `gradlew processResource` on *Windows* or 
`./gradlew processResource` on *Mac/Linux*  (If you are encountered a permission error: `./gradlew: Permission denied` add the executable permission to the 
the shell script by running `chmod 744 gradlew` in your terminal)
It should finish with the `BUILD SUCCESSFUL` message. This will generate the resources required by the application and tests.

=== 1.3. Verifying the setup

. Run Duke to verify and try a few commands. (Refer here {insert link to the command page} the commands)
. Run the JUNIT Test/gradlew test command to ensure that all the test case passes.
// . <<Testing#,Run the tests>> to ensure they all pass.

// === 1.4. Configurations to do before writing code

// ==== Configuring the coding style

// This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

// . Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
// . Select `Editor` > `Code Style` > `Java`
// . Click on the `Imports` tab to set the order

// * For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
// * For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

// Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

// ==== Setting up CI

// Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

// After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

// [NOTE]
// Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

// Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

// [NOTE]
// Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

// ==== Getting started with coding

// When you are ready to start coding, we recommend that you get some sense of the overall design by reading about <<DeveloperGuide#Design-Architecture, Duke's architecture>>.

== 2. Design

=== Architecture Design
ArchDuke was implemented using the N-tier architecture approach. Having a N-tier application architecture helped s to
flexibly create the application by segregating the application into tiers. Hence instead of reworking the entire application
when the application is modified, we only had to rework the specific layer dealing with the modification. This approach also
helped us in logically structuring the elements which made up ArchDuke. The Architecture Diagram given below explains the
high-level design of ArchDuke.

.Architecture Diagram
image::images/ArchDuke_Architecture.png[]

Below is a quick overview of each component based on our Architecture.

Not included in the diagram is the `Main` program in the folder *_launcher_*. The Main program is responsible for
initializing the `View` layer.

* In our case, as ArchDuke is a command line program, `Main` will initialize `CLIView`.

`Utility` represents a collection of classes used by multiple other components and can be accessed by all layers.

* `Factory` classes : Used mainly by `Repositories` and `Controllers` to create objects based on user input.
* `Logger` classes: Used by all classes to write log messages to ArchDuke's log file.
* `ParserHelper` class: Used by all classes for user input parsing.
* `SortHelper` class: Used primarily by `Repositories` and `Controllers` for sorting objects based on description
before a Response model is generated for the `View` layer.
* `DateTimeHelper` class: Used for handling anything that is related to Date objects or parsing inputs for Date objects

The rest of the App consists of four main layers.

* `View` layer: The UI of ArchDuke. Responsible for printing everything that the user will see and reading inputs
from the user.
* `Controller` layer: Responsible for handling user inputs and sending them to the respective classes for parsing,
cleaning, or object creation.
* `Repository` layer: Responsible for holding data in-memory
* `Data` layer: Responsible for saving and loading persistent data from hard disk.

Each layer will be discussed in detail below.
// Each of the four components

// * Defines its _API_ in an `interface` with the same name as the Component.
// * Exposes its functionality using a `{Component Name}Manager` class.

// For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

// .Class Diagram of the Logic Component
// // image::LogicClassDiagram.png[]

// [discrete]
// ==== How the architecture components interact with each other

// The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

// .Component interactions for `delete 1` command
// // image::ArchitectureSequenceDiagram.png[]

// The sections below give more details of each component.

=== 2.1. View Layer
Our main UI Component is a class called CLIView. It is mainly responsible for reading the user input and displaying
formatted messages to the user.

When ArchDuke is running, CLIView repeatedly reads the user input line by line, and sends it to the parsing components
(Controllers) to make sense of the input. Eventually, the controllers will retrieve the relevant messages and
information for CLIView to display.

// .Structure of the UI Component
// image::UiClassDiagram.png[]

=== 2.2. Controller Layer

// [[fig-LogicClassDiagram]]
// .Structure of the Logic Component
// image::LogicClassDiagram.png[]
// *API* :
// link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

==== 2.2.1. ConsoleInputController
`ConsoleInputController` is the class which deals with the CRUD functionalities for all the projects of the user.

*Rationale for implementation*

==== 2.2.2 ProjectInputController
`ProjectInputController` is the class which deals with the management of a specific project.

*Rationale for implementation*

We realized that the commands related to managing a project are extremely complex. Hence we had to segregate the methods related
to managing a single project from the `ConsoleInputController` and this resulted in the creation of the `ProjectInputController`.

When the project is being managed, all the commands input by the user are directly handled by the `ProjectInputController`.
Hence, `ProjectInputController` acts like a parser for commands dealing with the CRUD functionalities for Members, Tasks,
Task Assignments and Reminders. Control is handed back to the `ConsoleInputController` after exiting from managing a project.

==== 2.2.3 AssignmentController
`AssignmentController` is a class which manages the assignment of tasks to group members. It is invoked by `ProjectInputController`
when the user inputs the "assign task" command. It first ensures that the input is valid by ensuring that there are sufficient
parameters (task index numbers, member index numbers). It then accesses the respective `Project` to create or remove assignments between
`Member` and `Task` objects. These assignments are recorded within the `Project` itself in the form of Java HashMaps.

This controller contains a `ParserHelper` to help parse assignment commands, and two separate ArrayLists to store
error or success messages to display to the user regarding task assignments.

*Rationale for implementation*
Before the implementation of `AssignmentController`, the parsing of assign commands was planned to be done within the
`ProjectInputController` class. However, we realised that parsing for assignment commands would be extremely complex due
to the potentially high number of arguments and operations that need to be done.
Separate methods would be needed to handle assignments and unassignments, with one unifying method that combines and
executes one or both based on the user input.

Creating the `AssignmentController` class ensures a higher cohesion as all methods related to managing assignments between
tasks and members are isolated into a single, focused class. It can help to fulfill the Separation of Concerns Principle.

=== 2.3. Repository layer

// .Structure of the Model Component
// image::ModelClassDiagram.png[]

// *API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

// The `Model`,

// * stores a `UserPref` object that represents the user's preferences.
// * stores the Address Book data.
// * exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
// * does not depend on any of the other three components.

// [NOTE]
// As a more OOP model, we can store a `Tag` list in `Address Book`, which `Person` can reference. This would allow `Address Book` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
//  +
// image:BetterModelClassDiagram.png[]

=== 2.4. Data Layer

// .Structure of the Storage Component
// image::StorageClassDiagram.png[]

// *API* : 
// link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

//The `Storage` component,

// * can save `UserPref` objects in json format and read it back.
// * can save the Address Book data in json format and read it back.

//[[Design-Commons]]
=== 2.5. Utility Classes
//Classes used by multiple components are in the `seedu.addressbook.commons` package.

Classes used by multiple components are in the 'util' package. Within this package are several subpackages that
assist the functionality of ArchDuke. The following table shows a description of these classes.

[width="100%",cols="22%,<50%",options="header",]
|=======================================================================
|Class | Functionality
|ArchDukeLogger|
|AssignmentViewHelper|
|CommandHelper|
|ConstantHelper|
|DateTimeHelper|
|MemberFactory|
|JsonConverter|
|ParserHelper|
|ProjectFactory|
|ReminderFactory|
|SortHelper|
|TaskFactory|
|ViewHelper|
|=======================================================================

== 3. Implementation
This section describes in detail on how certain features of ArchDuke are implemented. Most features are based on
Create, Read, Update, Delete, also known as *CRUD* functions

=== 3.1. CRUD functionality for Projects
==== Implementation

CRUD functions are facilitated by `ConsoleInputController`, `ProjectRepository` and `ProjectFactory`. It allows
ArchDuke to be able to do some basic CRUD functions for a Project, namely only Creation, Reading and Deletion.
`ConsoleInputController` will
read the relevant
commands from the `View` layer and call the relevant methods in `ProjectRepository`.

It implements the following commands:

* `create PROJECT_NAME` -- Creation of a new Project
* `list` --  Viewing all Projects that have been created
* `delete PROJECT_INDEX` -- Delete a Project that has been created previously

These operations are exposed in the `IRepository` interface as `addToRepo()`, `getAll()` and `deleteItem()`.

[NOTE]
However, in order to create a object, inputs sent to the `Repository` layer must be sent to a `Factory` class as the
`Repository` layer is not responsible for the creation of Objects.

The example usage scenario below will explain in detail the data flow and how the program behaves at each step of
CRUD functions with regards to a Project object.

Step 1) ArchDuke is launched for the first time by the user. A new `CLIView()` and `ConsoleInputController` is
created upon initialization. Immediately after initialization, `CLIView.start()` will be called which prints a welcome
message to the user and awaits for user input.

Step 2) The user executes the command `create Avengers Assemble!` to create a new Project with the description
"Avengers Assemble!". User input is fed from `CLIView` to `ConsoleInputController`, where simple parsing will be done
to determine the type of command that the user has executed.

Step 3) User input will be understood as a command to create a new project and thus sent to `ProjectRepository` where
it will call on `ProjectFactory` for the creation of a new Project object.

Step 4) `ProjectRepository` will check if `ProjectFactory` managed to create an object successfully. Any unsuccessful
creation will be due to wrong user commands or a bug during data validation in `ProjectFactory`.

Step 5) Assuming Project creation was a success, `ProjectRepository` will store it in an ArrayList and return `True`
back to `ConsoleInputController` to signify the successful creation of a new Project object. `ConsoleInputController`
will call `CLIView` to print appropriate messages to the user based on whether a new Project object was created
successfully or not.

The following sequence diagram shows how the `create PROJECT_NAME` operation works.

image::images/ProjectCreation_Sequence.png[]

The `delete PROJECT_INDEX` command works similarly to `create PROJECT_NAME`. Both commands will result in a
`Boolean` of either `True` or `False` to indicate whether command was executed successfully. There are minor
differences, listed below:

* Instead of creating a new Project object, the `delete PROJECT_INDEX` command will call `deleteItem()` in
`ProjectRepository` instead of `addToRepo()`.
* Deletion of Project works by Project Index instead of Project Name.

*Manage project*

ArchDuke allows users to manage each individual project in the `ProjectRepository`.

image::images/ManageProject_Sequence.png[]
=== 3.2 CRUD functionality for Members
==== Implementation

CRUD Member functions are handled by Member, MemberList, MemberFactory, Project and ProjectInputController.
It allows ArchDuke to perform simple CRUD function for Member in the Project, these simple functions include Create, Read,
Update and Delete. ProjectInputController will read the relevant command related to the member function and call the relevant methods in ParserHelper.

It implements the following commands:

* `add member -n MEMBER_NAME [-i MEMBER_PHONE_NUMBER] [-e MEMBER_EMAIL]` -- Creates a new Member with the member name, phone number (optional)
 and email address (optional).
* `edit member MEMBER_INDEX [-n MEMBER_NAME] [-i PHONE_NUMBER] [-e MEMBER_EMAIL]` -- Updates an existing member details
based on the member index with the new attributes specified.
* `view members`-- Displays all the members in the current project.
* `view credits`-- Displays the compiled credits of all members from their individually assigned tasks.
* `role INDEX -n MEMBER_NAME`-- Assigns roles to specific members using their names.
* `delete member MEMBER_INDEX`--Deletes a member from the current project using the member index.

The example usage scenario will explain in detail the data flow and how the program behaves at each step of CRUD
functions with regards to a `Member` object.

Step 1) The user creates a new project and chooses to manage it.

Step 2) The user executes the command `add member -n Charles Wong -i 95674325 -e charles@gmail.com` to create a new member
with the name "Charles Wong" whose phone number is "95674325" and whose email address is "charles@gmail.com".

Step 3) The `ProjectInputController.manageProject()` method triggers the `MemberFactory` which does the validation of the input.

Step 4) `MemberFactory` then goes on to call `parser.parseMemberDetails()` to do a simple parsing which will clean up
the flags and will return an `ArrayList<String>` for MemberFactory to create the member.

Step 5) `MemberFactory` will create the member based on the information provided by the user. The created member will
subsequently be added into `memberList` which holds all the members in the current project. Upon doing successfully or
unsuccessfully doing so, a String message will be returned.

image::images/CreateMember_Sequence.png[]

=== 3.3. CRUD functionality for Tasks
==== Implementation

CRUD Task functions are handled by `Task`, `TaskList`, `TaskFactory`, `Project` and `ProjectInputController`.
It allows ArchDuke to perform simple CRUD function for Task in the Project, these simple functions include Create, Read,
Update and Delete. `TaskFactory` will create the relevant task with the appropriate input from the user which will then be
added into the `TaskList` managed by the `Project`. `ProjectInputController` will read the relevant command related to task
function and call the relevant methods in `TaskFactory` And `ParserHelper`.

It implements the following commands:

* `add task -t TASK_NAME  -p TASK_PRIORITY -c TASK_CREDIT [-d TASK_DUE_DATE] [-s TASK_STATE] [-r TASK_REQUIREMENTS]` -- Creates a
new Task with the task name, priority, credit, due date (optional), state(optional) and additional requirements (if any).

* `edit task TASK_INDEX -t TASK_NAME -p TASK_PRIORITY -c TASK_CREDIT [-d TASK_DUE_DATE] [-s TASK_STATE]` -- Updates existing task attributes with the new input
values.

* `view tasks` -- Displays all tasks in current project.

* `view tasks /MODIFIER` -- Displays tasks sorted based on the attribute specified by the user.

* `view task requirements TASK_INDEX` -- Displays all additional requirements of a specified task.

* `edit task requirements TASK_INDEX rm/TASK_INDEXES r/TASK_REQUIREMENT1` -- Updates task requirements of specified task by
removing unwanted requirements and adding new ones.

* `delete task TASK_INDEX` -- Deletes task with stated index.

The example usage scenario below will explain in detail the data flow and how the program behaves at each step of CRUD
functions with regards to a `Task` object.

Step 1) Assuming Project have been created and the user is currently managing a specific project.

Step 2) The user execute the command `add task -t kill thanos! -p 100 -c 100` to create a new task with the task
name “kill thanos!”, priority value “100” and a credit of “100”. These input will be consumed by `ProjectInputController.manageProject()`

Step 3) The `ProjectInputController.manageProject()` will trigger the `TaskFactory` which will do a  validation to ensure the
required input are given.

Step 4) `TaskFactory` will then call parserHelper.parseTaskDetails() to do a simple parsing which will clean up the
flags and return `ArrayList<String>` for `TaskFactory` to create the task.

Step 5) `TaskFactory` will create the task based on the information given by the user. The created task will subsequently
be added into `taskList` managed by the project and a successfully or unsuccessfully a message in String[] will be returned.

The following sequence diagram show how `add task` operation works.

image::images/CreateTask_Sequence.png[]

=== 3.4. CRUD functionality for Reminder [Plan to do]
==== Implementation

CRUD Reminder functions are handled by `Reminder`, `ReminderList` and `ReminderFactory`,`Project` and `ProjectInputController`.
It allows ArchDuke to perform simple CRUD function for Reminder in the Project, these simple functions include Create, Read,
Update and Delete. `TaskFactory` will create the relevant task with the apporatied input from the user which will then be
added into the `TaskList` managed by the `Project`. `ProjectInputController` will read the relevant command related to task
function and call the relevant methods in `ReminderFactory` And `ParserHelper`.

Reminder function implements the following commands:

* `add reminder -n REMINDER_NAME -d REMINDER_DUEDATE -Tag REMINDER_TAG` -- Creation of a new Reminder with the reminder
name and due date (optional)

* `edit reminder TASK_INDEX -n REMINDER_NAME -d REMINDER_DUEDATE` -- Edits existing task with the new input values

* `view reminder` -- Viewing of all reminders in current project

The following sequence diagram show how `add reminder` operation works.

The example usage scenario below will explain in detail the data flow and how the program behaves at each step of CRUD
functions with regards to a `Reminder` object.

Step 1) Assuming Project have been created and the user is currently managing a specific project.

Step 2) The user execute the command `add Reminder -n Do System integration -d 31/10/2019` to create a new reminder with the reminder
name “Do System integration” on a specific date "31.10/2019". These input will be consumed by `ProjectInputController.manageProject()`

Step 3) The `ProjectInputController.manageProject()` will trigger the `ReminderFactory` which will do a validation to ensure the
required input are given.

Step 4) `ReminderFactory` will then call parserHelper.parseReminderDetails() to do a simple parsing which will clean up the
flags and return a `ArrayList<String>` with the relevant details for `ReminderFactory` to create the task.

Step 5) `ReminderFactory` will create the reminder based on the information given by the user. The created Reminder will subsequently
be added into `ReminderList` managed by the project and a successfully or unsuccessfully a message in String[] will be returned.

image::images/CreateReminder_Sequence.png[]

=== 3.5. CRUD functionality for Managing or Viewing Task Assignments

==== Implementation

CRUD Assignment functions are handled by `ProjectInputController`, `ParserHelper`, `AssignmentController`, `AssignmentViewHelper`
and `Project`.

ArchDuke allows users to track tasks and their assignments to members in a project.
Assignments establish a relationship between a task and a member. When a member is assigned a task,
they are expected to complete it, and will be given the stipulated credit when the task state is marked
as `DONE`. The degree of each member's contributions are measured by task credit.

Assignment functions implement the following commands:

* `assign task -i TASK_INDEX -to [MEMBER1_INDEX] [MEMBER2_INDEX] -rm [MEMBER3_INDEX]`
* `view assignments MODIFIER`

Upon creation, each `Task` and `Member` object are given a unique ID using the UUID class in Java. The ID
is stored as a String and is immutable throughout the lifetime of the object.
Assignments are tracked in the `Project` class by mapping the task IDs to the member IDs using 2 Java HashMaps:

* `taskAndListOfMembersAssigned`
** Key: String `taskID` of each task.
** Value: ArrayList<String> containing `memberID` of all members assigned to the respective task.

* `memberAndIndividualListOfTasks`
** Key: String representing `memberID` of each member.
** Value: ArrayList<String> containing `taskID` of all the tasks assigned to that particular member.

==== Making Assignments
The following steps show how task assignments are made in ArchDuke.

Step 1) Assume Project has been created and the user is currently managing a specific project.

Step 2) User enters the command `assign task -i 1 2 -to 1 2 3 -rm 4`. This indicates the user would like to assign tasks with index
number 1 and 2 to members 1, 2 and 3, and also unassign/remove the task from member 4.

Step 3) The `ProjectInputController.manageProject()` will call `projectAssignTask()`. A new `AssignmentController` will be created, and the
user input will be passed into the `assignAndUnassign()` method to manage the assignment.

Step 4) `AssignmentController` calls `ParserHelper.parseAssignmentParams()` to parse and split the input into 3 parts: the task index numbers, the assignee
index numbers, and the unassignees index numbers.

Step 5) `ParserHelper` checks all 3 sets of index numbers to ensure that they are valid (non-negative integers,
and exist within the project) using `ParserHelper.parseMembersIndexes()` and `ParserHelper.parseTasksIndexes()`.
`AssignmentController.checkForSameMemberIndexes()` checks if the list of assignees and unassignees contain any identical
index numbers, and remove them to avoid redundant work. ParserHelper returns all 3 sets of valid indexes to `AssignmentController`.

Step 5) If there are valid task numbers, a for loop is used to iterate through the tasks to handle the assignments
one by one. `AssignmentController.assign()` and `AssignmentController.unassign()` are called to assign or unassign
tasks to the members.

Step 6) `Project.containsAssignment()` is used to check if an assignment between a task and member already exists to
avoid any errors (for example, duplicating assignments or trying to remove an assignment which does not exist).
The errors are noted down by adding error messages to the ArrayList `errorMessages` which will be displayed to the user later.

Step 7) If the input is valid, the assignment is created by calling `Project.createAssignment()` or removed by calling
`Project.removeAssignment()`. The HashMaps are manipulated accordingly to note down the assignment between the specified task
and member. Success messages are stored in `successMessages` and are also displayed to the user later.

image::images/AssignmentSequenceDiagram.png[]

==== Viewing Assignments
The following steps show how task assignments can be viewed by the user in ArchDuke.

Step 1) Assume Project has been created and the user is currently managing a specific project.

Step 2) User enters a command to view assignments. This can be in one of the following formats:

* `view assignments -m` (to view each member's tasks)

* `view assignments -t` (to view each task's assigned members)

Each command is accompanied with a suffix `all`, or selected index numbers of members or tasks.

Step 3) The `ProjectInputController.manageProject()` will call `projectViewAssignments()` to validate the
input by checking that there are sufficient parameters by checking input length, and ensuring that there is
a valid flag (`-m` or `-t`).

Step 4) Depending on the flag in the user input, `projectViewAssignments()` calls 1 of 2 the helper methods:

* Member flag `-m`: projectViewMembersAssignments() is called.
** `ParserHelper.parseMemberIndexes` is called to parse the valid member indexes.
** `AssignmentViewHelper.getMemberOutput` is called to retrieve the assignments for the selected members.
It accesses the HashMap `memberAndIndividualListOfTasks`


* Task flag `-t`: projectViewTasksAssignments() is called.
** `ParserHelper.parseTaskIndexes` is called to parse the valid task indexes.
** `AssignmentViewHelper.




==== Design Considerations

===== Aspect: How to keep track of Assignments

* **Alternative 1 (current choice):** Use 2 HashMaps which store IDs of tasks and members in Project class
[HashMaps]

* `taskAndListOfMembersAssigned`
** Key: String `taskID` of each task.
** Value: ArrayList<String> containing `memberID` of all members assigned to the respective task.

* `memberAndIndividualListOfTasks`
** Key: String representing `memberID` of each member.
** Value: ArrayList<String> containing `taskID` of all the tasks assigned to that particular member.

** Pros:
*** 1) Allows fast and easy writing and retrieval of data.
*** 2) `Task` and `Member` objects to not need to be aware of each other in order to maintain the assignment.
Assignments can be managed entirely by the project itself, which reduces coupling between `Task` and `Member` objects.
** Cons:
*** 1) `Task` and `Member` objects must be retrieved manually by iterating through the `taskList`/`memberList` to find
the corresponding object with the matching ID.

* **Alternative 2: ** Use 2 HashMaps in Project class which store
[HashMaps]
Similar to Alternative 1, but instead of storing String IDs, the objects themselves are stored.
** `taskAndListOfMembersAssigned`
*** Key: `Task`
*** Value: ArrayList of assigned `Member` objects (List of members assigned to task)

** `memberAndIndividualListOfTasks`
*** Key: `Member`
*** Value: ArrayList of `Task` objects (List of each member's individual tasks)

** Pros: (same as in Alternative 1)
*** 1) Allows fast and easy writing and retrieval of data.
*** 2) Task and Member objects to not need to be aware of each other in order to maintain the assignment.
Assignments can be managed entirely by the project itself.
** Cons:
*** 1) Complications associated with hashing non-primitive objects, and hashCode needs to be overwritten to
ensure proper hashing.
*** 2) Key or values could not be updated in the HashMap when task/member details changed. This resulted in
inconsistent task and member information being stored in the 2 HashMaps, and outdated information being
retrieved when viewing assignments.

 * **Alternative 3:** Each `Task` maintains an ArrayList of assigned members, and each `Member` maintains an
ArrayList of assigned tasks.
 ** Pros:
 *** 1) More intuitive.
 ** Cons:
 *** 1) Cyclic dependencies will exist between Task and Member objects, making it difficult to edit and change task
assignments. This also results in increased and unnecessary coupling.


// ===== Aspect: Data structure to support the undo/redo commands

// * **Alternative 1 (current choice):** Use a list to store the history of address book states.
// ** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
// ** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
// * **Alternative 2:** Use `HistoryManager` for undo/redo
// ** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
// ** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// end::undoredo[]

// tag::dataencryption[]
// === 3.2. [Proposed] Data Encryption

// _{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

=== 3.6. UI functionality for displaying information

==== Implementation

UI functions are handled by `CLIView`, `ViewHelper`, and the data layer which stores the details of projects,
members and tasks. It allows ArchDuke to present useful information to the user in an easily readable format when
requested. The information will be presented in a table form with a clear header that describes the content and
has the information in bullet point form.

The UI display uses the following methods to produce a table:

* `consolePrintTable()` -- Main method that constructs the table. Returns a String array with each element
representing one row of the table
* `consolePrintTableHoriBorder()` --  Returns a String containing the horizontal border of the table
* `getRemainingSpaces()` -- Returns a String containing the remaining number of spaces required to fill up the rest of
the line
* `getArrayOfSplitStrings()` -- When a String that is meant to be in one row in the table is too long, it is passed
into this method to split the string up into an array of Strings of suitable length to fit into one row of the table

The following steps show how the UI table display are made in ArchDuke.

Step 1) User enters a command that requires information to be presented in a clear format such as `list`, `view members`,
`view tasks` etc.

Step 2) Assume the command `list` is entered. The user is requesting an overview of all the projects that he is currently doing.
This would call the method `getAllProjectDetailsForTable()` in `ProjectRepository`.

Step 3) The method `getAllProjectDetailsForTable()` would return an ArrayList containing multiple ArrayLists of String, with each
ArrayList of String containing all the details of each project which will be stored in one table. The parent ArrayList
would then contain information to be printed in different tables. In this case, each project will fill one table.

Step 4) The ArrayList of ArrayLists would then be passed into the `consolePrintTable()` method, which will pack each individual
ArrayList of Strings into a formatted table. Each String in the ArrayList of Strings is an entry that is meant to be presented
in one line of the table.

Step 5) When the String is shorter that the full table width, there are spaces that need to be added to maintain the visual
implementation of the table. Hence, the `getRemainingSpaces()` method is called to fill up the remaining spaces.

Step 6) When the String is longer than the full table width, it needs to be split into multiple lines in order to fit it
within the table. Hence, the `getArrayOfSplitStrings()` method is called to split the string up nicely to fit the table width.
It will ensure that the String is split at the spaces so that the words remain intact. The only exception is when the length
of a word is longer than the table width. the method would append a hyphen '-' at the point of the word where it exceeds table width
and push the remainder to the next line.

Step 7) The `consolePrintTableHoriBorder()` method is called at any point where the horizontal border of the table is required.

Step 8) The `consolePrintTable()` method would then store the entire series of tables to be displayed into a String array
with each element containing a line to be printed to be passed into `consolePrint()` where it will be printed with
indentation and horizontal borders on the top and bottom.

The following sequence diagram show how `list` operation works.

image::images/ViewAllProjects_Sequence.png[]

=== 3.7. Logging

We are using `org.apache.logging.log4j` package for logging. The `ArchDukeLogger` class under `Utility` layer is used for
logging every step that ArchDuke takes so that debugging will be easier.

* The logging level is controlled by property name `rootLogger.level` in `log4j2.properties`. Currently the level is set to all.
(Show all log level message)

* The `ArchDukeLogger` call by using ArchDukeLogger.logInfo(className, Message); function which will log the
message according to the specified logging level method called.

* Currently all the log messages are store in the log file located in the logs directory

The `log4j2.properties` file in the resource folder is used configure the following:

* RootLogger level - The level root logger to be shown in the log file. Currently it is set to `all`

* File Appender - The file direction and log file name. The log file can be found in the logs folder.

* PatternLayout - The output format message displayed in the log file

The following shows the class diagram of ArchDukeLogger

image::images/classDiagram/ArchDukeLogger_ClassDiagram.png[]

[NOTE]
If any bugs or errors encountered during the testing, please do create an issue on this repo and upload the logs file located
is the `logs` directory.

//* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
//* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
//* Currently log messages are output through: `Console` and to a `.log` file.
//
//*Logging Levels*
//
//* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
//* `WARNING` : Can continue, but with caution
//* `INFO` : Information showing the noteworthy actions by the App
//* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

// [[Implementation-Configuration]]
// === 3.4. Configuration

// Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== 4. Documentation

// Refer to the guide <<Documentation#, here>>.
We chose to use AsciiDoc to write the documentation. This is because Ascii syntax is consistent and there is a flexibility offered
for essential syntax unlike MarkDown.



== 5. Testing

// Refer to the guide <<Testing#, here>>.

== 6. Dev Ops

// Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* Team leaders of group projects
* Group project team leaders who monitor contributions of team members
* Project managers who track progress for multiple projects
* Teachers who evaluate and act upon their students’ progress
* Technical professionals who keep track of task deadlines
* Project planners who plan out priority and assignment of roles

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="100%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |project leader |be able to track deadlines for each project |prioritize which project to be completed earlier

|`* * *` |project leader |be able to manage multiple projects and view all the task delegations of my team members in them |distribute my resources appropriately

|`* * *` |project leader |be able to create projects |keep track of all my projects using a command line application

|`* * *` |project leader |be able delete projects that are completed |have a cleaner working environment

|`* * *` |project leader |view a progress bar for each project |have a clearer view of the total progress for each project

|`* * *` |project leader |manage my team members |assign different roles to team members so that they are clear of their relevant roles

|`* * *` |project leader |manage my team members |assign different tasks to team members so that they will be clear of the work that they are supposed to do

|`* * *` |project leader |add team members to a specific group project |assign different roles and tasks to them
based on the project they belong to

|`* * *` |project leader |update the details of my team members |have up to date information about them whenever needed

|`* * *` |project leader |remove members from a particular project |remove unwanted or old members from a project
that they are no longer contributing

|`* * *` |project leader |keep track of each member’s progress and contributions |ensure all students contribute to their respective tasks sufficiently

|`* * *` |project leader |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |project leader |generate a report of the contributions of the members |credit can be rightfully assigned to the respective members

|`* * *` |project leader |indicate the credit of each task |track the level of contribution by each member

|`* * *` |project leader |track the status of every task |track the progress of each project

|`* * *` |project leader |indicate the priority of the tasks |ensure members know what order to be done

|`* * *` |project leader |input the requirements of the tasks I have been assigned |ensure needs members are clear about what needs to be done

|`* * *` |project leader |be able to track deadlines for each task |I will know if a group member is slacking.

|`* * *` |project leader |assign one task to multiple students |more than one student can contribute to the task

|`* * *` |project leader |delete erroneous tasks from the project I am managing| prevent any confusion and achieve a
cleaner work space

|`* * *` |project leader |view tasks sorted by name, index, date, priority, credit, assigned member names or Kanban
board style | I can view all the tasks in a customised manner according to the required scenario.

|`* * *` |project leader |import files from other sources |track all my projects from different workstations or work environments

|`* * *` |project leader |be able to edit and read the exported file |have other people can add in details as well into the file and send back

|`* * *` |project leader |have a good overview of all the projects I am managing |I can distribute my resources appropriately

|`* * *` |project leader |define a clear end goal/target for the project |that we stay on the right track

|`* * *` |project leader |I can view the tasks and roles that I have assigned |ensure members can complete them

|`* * *` |project leader |keep track of the contributions of members |ensure everyone does his/her fair share

|`* * *` |project leader |create task dependencies |members can complete tasks in a certain order

|`* * *` |project leader |calculate the total weightage of tasks done by each member |keep track of the amount of contributions done by each member

|`* *` |project leader |schedule project meet-ups |group members can meet at a stipulated date and time

|`* *` |project leader |be able to export the relevant details for each project |send it to other people for viewing

|`* *` |project leader |be able to export the details for each project in different formats |avoid compatibility issues with a specific file format

|`* *` |project leader |view a calendar with all tasks, milestones and deadlines |easily visualise the progress of the project

|`* *` |project leader |have a more intuitive way to view the current task and role assigned to a particular team member |better manage their well being

|`* *` |project leader |be able to track the technical and non-technical roles assigned to my team members |I can keep track of the overall progress of the project

|`* *` |project leader |define milestones to track the progress of the entire project |have users work towards each milestone sequentially

|`*` |project leader |save time managing my team members from the manual way of tracking my group progress |make this group can be as efficient as possible

|`*` |project leader |change the assignment of tasks halfway through the project |cater to different needs and schedules of team members
|=======================================================================

_{To be edited}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `ArchDuke` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Create project (UC01)

*MSS*

1.  User requests to create project with desired project name and number of members
2.  ArchDuke creates a project named after desired project name and number of members
+
Use case ends.

*Extensions*

[none]
* 1a. The given input is wrong.
** 1a1. ArchDuke shows an error message.
+
Use case ends.

[discrete]
=== Use case: View all projects (UC02)

*MSS*

1.  User requests to view all projects.
2.  ArchDuke shows a list of all projects with their respective details.
+
Use case ends.

*Extensions*

[none]
* 1a. The given input is wrong.
** 1a1. ArchDuke shows an error message.
+
Use case ends.

[discrete]
=== Use case: Manage a project (UC03)

*MSS*

1.  User requests to view all projects.
2.  ArchDuke shows a list of all projects with their respective details.
3.  User requests to manage a project specified in the list.
4.  ArchDuke opens up the specified project.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
** 3a1. ArchDuke shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Add members to a specific project (UC04)

*MSS*

1.  User [underline]#selects a specific project to manage (UC03)#.
2.  User enters command to add member specifying at least the member's name.
    Phone number and email address are optional.
3.  ArchDuke adds specified member into current project.
+
Use case ends.

*Extensions*

[none]

* 2a. The given information (member details) is invalid.
** 2a1. ArchDuke shows an error message.
+
Use case resumes at step 1.

* 2b. The user enters the name of a member already in the project.
** 2b1. ArchDuke shows an error message informing user of existing member.

[discrete]
=== Use case: Edit members in a specific project (UC05)

*MSS*

1.  User [underline]#selects a specific project to manage (UC03)#.
2.  User requests to edit member specifying member index and fields that require editing.
3.  ArchDuke edits specified fields of specified member in current project.
+
Use case ends.

*Extensions*

[none]
* 2a. The given index is invalid.
** 2a1. ArchDuke shows an error message prompting user to check again and enter the correct index.
+
Use case resumes at step 1.

[discrete]
=== Use case: Add task in a specific project (UC06)

*MSS*

1.  User [underline]#selects a specific project to manage (UC03)#.
2.  User requests to add task.
3.  ArchDuke adds task to current project.
+
Use case ends.

[discrete]
=== Use case: Edit task in a specific project (UC07)

*MSS*

1.  User [underline]#selects a specific project to manage (UC03)#.
2.  User requests to edit task specifying task index and fields that require editing
3.  ArchDuke edits specified fields of specified task in current project.
+
Use case ends.

*Extensions*

[none]
* 2a. The given index is invalid.
** 2a1. ArchDuke shows an error message.
+
Use case resumes at step 1.

[discrete]
=== Use case: Assign tasks to members (UC08)

*MSS*

1.  User [underline]#selects a specific project to manage (UC03)#.
2.  User requests to assign/unassign a specific task to one or several members.
3.  ArchDuke assigns/unassigns specified members to specified task in current project.
+
Use case ends.

*Extensions*

[none]
* 2a. User enters invalid index numbers of tasks/members.
** 2a1. ArchDuke shows error messages indicating invalid index numbers of respective tasks/members.
+
Use case resumes from step 2.

[none]
* 2b. User tries to assign task to someone who has already been assigned the task, or unassigns
** 2b1. ArchDuke shows error message indicating unsuccessful assignments.
+
Use case resumes from step 2.

[discrete]
=== Use case: Complete tasks in a specific project (UC09)

*MSS*

1.  User [underline]#selects a specific project to manage (UC03)#.
2.  User requests to mark a specific task as completed.
3.  ArchDuke marks specified task in current project as completed.
+
Use case ends.

*Extensions*

[none]
* 2a. The given index is invalid.
** 2a1. ArchDuke shows an error message.
+
Use case resumes at step 1.

[discrete]
=== Use case: Generate report for a specific project (UC10)

*MSS*

1.  User [underline]#selects a specific project to manage (UC03)#.
2.  User requests to generate a report of of the project and members' contributions.
3.  ArchDuke gathers information from tasks, and presents it in a report.
4.  ArchDuke saves a copy of the report in a readable format to the hard disk.


// _{More to be added}_

[appendix]
== Non Functional Requirements

1. ArchDuke should be able to run on any machine with Java Development Kit (JDK 11) installed.
2. ArchDuke should be able to handle up to a thousand tasks and projects.
3. ArchDuke should be secure, to prevent unauthorised modification.
4. ArchDuke should not save passwords in plain text.
5. ArchDuke should be smooth and fast to view and edit.
6. ArchDuke output should be organised clearly with proper tabbing.

//[appendix]
//== Glossary

// [[mainstream-os]] Mainstream OS::
// Windows, Linux, Unix, macOS

// [[private-contact-detail]] Private contact detail::
// A contact detail that is not meant to be shared with others
